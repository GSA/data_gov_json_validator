<?php
/**
 * User: ykhadilkar
 * Date: 11/20/13
 * Time: 11:34 AM
 */

use JsonSchema\Validator;
use JsonSchema\Uri\UriRetriever;

/**
 *
 * Documentation
 * http://docs.ckan.org/en/latest/api.html#ckan.logic.action.get.package_search
 */
define('CKAN_URL', "http://catalog.data.gov/api/3/action/package_search");

/**
 * @return array
 */
function data_gov_json_validator_menu(){
    $items = array();

    $items['json-validator'] = array(
        'title' => 'Data.gov JSON Validator',
        'page callback' => 'data_gov_json_validator_validator_form',
        'access arguments' => array('access content'),
    );

    return $items;
}

/**
 *
 */
function data_gov_json_validator_validator_form()
{
    $schema_file_path = DRUPAL_ROOT.'/'.drupal_get_path('module', 'data_gov_json_validator').'/schema/schema_1_0_final.json';
    $data_dir = DRUPAL_ROOT.'/'.drupal_get_path('module', 'data_gov_json_validator').'/data/';
    define('RESULTS_LOG', DRUPAL_ROOT.'/'.drupal_get_path('module', 'data_gov_json_validator').'/results/processing');
    is_file(RESULTS_LOG) && unlink(RESULTS_LOG);

    foreach (glob($data_dir.'*.json') as $dataset) {
        data_gov_json_validator($dataset, $schema_file_path, true);
    }
}

/**
 * @param $data_file_path
 * @param $schema_file_path
 * @param bool $search_enabled
 */
function data_gov_json_validator($data_file_path, $schema_file_path, $search_enabled = false){
    $basename = basename($data_file_path);
    error_log('---===---===---===---'.PHP_EOL, 3, RESULTS_LOG);
    error_log('Processing '.$basename.' started ... '.PHP_EOL, 3, RESULTS_LOG);
    // Register the autoloader and ensure the library is available.
    composer_manager_register_autoloader();
    // Get the schema and data as objects
    $retriever = new UriRetriever;

    //get data
    $data_string = file_get_contents($data_file_path);
    $data_array = json_decode($data_string);

    $success = false;
    $json_file_error = 'Input JSON file could not be decoded: ';
    switch (json_last_error()) {
        case JSON_ERROR_NONE:
            $success = true;
            break;
        case JSON_ERROR_DEPTH:
            error_log($json_file_error.' - Maximum stack depth exceeded'.PHP_EOL, 3, RESULTS_LOG);
            break;
        case JSON_ERROR_STATE_MISMATCH:
            error_log($json_file_error.' - Underflow or the modes mismatch'.PHP_EOL, 3, RESULTS_LOG);
            break;
        case JSON_ERROR_CTRL_CHAR:
            error_log($json_file_error.' - Unexpected control character found'.PHP_EOL, 3, RESULTS_LOG);
            break;
        case JSON_ERROR_SYNTAX:
            error_log($json_file_error.' - Syntax error, malformed JSON'.PHP_EOL, 3, RESULTS_LOG);
            break;
        case JSON_ERROR_UTF8:
            error_log($json_file_error.' - Malformed UTF-8 characters, possibly incorrectly encoded'.PHP_EOL, 3, RESULTS_LOG);
            break;
        default:
            error_log($json_file_error.' - Unknown error'.PHP_EOL, 3, RESULTS_LOG);
            break;
    }

    if (!$success) {
        return;
    }

    //get schema
    $schema = $retriever->retrieve('file://' . $schema_file_path);

    // If you use $ref or if you are unsure, resolve those references here
    // This modifies the $schema object
    $refResolver = new JsonSchema\RefResolver($retriever);
    $refResolver->resolve($schema, 'file://' . __DIR__);
    $json_validation_results = array();

    $valid = $invalid = 0;

    foreach($data_array as $data) {
        // Validate
        $validator = new JsonSchema\Validator();
        $validator->check($data, $schema);
        $id = md5($data->identifier.$data->title);
        $json_validation_results[$id]["Title"] = $data->title;
        $json_validation_results[$id]["identifier"] = $data->identifier;
        if ($validator->isValid()) {
            $json_validation_results[$id]['Valid'] = True;
            $valid++;
        } else {
            $invalid++;
            $json_validation_results[$id]['Valid'] = False;
            foreach ($validator->getErrors() as $error) {
                $json_validation_results[$id]['Errors'][] = $error;
            }
        }
    }
    $json_total_results = json_encode($json_validation_results, JSON_PRETTY_PRINT);
    $resultsFile = str_replace('.json', '_results.json', $basename);
    file_put_contents(__DIR__ . '/results/'.$resultsFile, $json_total_results);
    error_log(" VALID: $valid ; INVALID: $invalid ; ".PHP_EOL, 3, RESULTS_LOG);
//    print_r($json_total_results);

    //search CKAN.
    //TODO: Optimize search. Use only one for loop for validation as well as search may be.
    if ($search_enabled) {
        data_gov_json_validator_csv_report($data_array, $json_validation_results, $basename);
    }
}

/**
 * @param $data_array
 * @param $json_validation_results
 */
function data_gov_json_validator_csv_report($data_array, $json_validation_results, $basename){

    $resultsFile = str_replace('.json', '_results.csv', $basename);
    $fp = fopen(__DIR__.'/results/'.$resultsFile, 'w');

    $csv_header = array(
        'Dataset Title in JSON',
        'Access URL in JSON',
        'Valid to POD Schema',
        'Number of Errors',
        'Number of Matches in catalog.data.gov',
        'Access URL match flag',
        'Is Geospatial',
        'catalog.data.gov URLs for matches found',
    );

    fputcsv($fp, $csv_header);

    $data_chunks = array_chunk($data_array, 10);
    foreach ($data_chunks as $data_chunk) {
//        prepare solr search request
        $titles = $original_titles = array();
        foreach ($data_chunk as $data) {
            $original_titles[] = $data->title;
            $titles[] = '('.escapeSolrValue($data->title).')';
        }
        $title = '('.join(' OR ', $titles).')';
        $base_output = data_gov_json_validator_search_solr($title);

        //convert to an array
        $base_output_array = json_decode($base_output,true);

        if (!isset($base_output_array['result'])) {
//            error_log('No results  for these titles:'.PHP_EOL, 3, RESULTS_LOG);
//            error_log(join(PHP_EOL, $original_titles).PHP_EOL, 3, RESULTS_LOG);
//            error_log($base_output.PHP_EOL, 3, RESULTS_LOG);
        } elseif ($base_output_array['result']['count'] > $sz = sizeof($base_output_array['result']['results'])) {
            error_log("Too many results (".$base_output_array['result']['count'].") for these titles:".PHP_EOL, 3, RESULTS_LOG);
            error_log(join(PHP_EOL, $original_titles).PHP_EOL, 3, RESULTS_LOG);
        }

        foreach ($data_chunk as $data) {
            $result_urls = "";
            $result_urls_access_url_no_match = "";
            $is_geospatial = "na";
            $access_url_match = "no";
            $number_of_matches = 0;

            if(
                isset($base_output_array['result']) &&
                is_array($base_output_array['result']) &&
                is_array($base_output_array['result']['results'])){

                //number of results
                $number_of_results = sizeof($base_output_array['result']['results']);

                //If one or more matches found then try to match access URL
                if ($number_of_results){
                    $no_match = array();
                    foreach($base_output_array['result']['results'] as $ckan_result){
                        if (trim($data->title) !== trim($ckan_result['title'])) {
                            continue;
                        }
                        $number_of_matches++;

                        $is_geospatial = 'false';
                        if (isset($ckan_result['extras'])) {
                            foreach ($ckan_result['extras'] as $extra) {
                                if ('metadata_type' == $extra['key'] && 'geospatial' == $extra['value']) {
                                    $is_geospatial = 'true';
                                }
                            }
                        }

                        $resourceUrl = trim($ckan_result['resources'][0]['url']);

                        if($resourceUrl === trim($data->accessURL)){
                            $result_urls .= "http://catalog.data.gov/dataset/".$ckan_result['name'];
                            $access_url_match = 'yes';
                            break;
                        }

                        if ('no' == $access_url_match && isset($data->distribution)) {
                            foreach ($data->distribution as $distribution) {
                                if ($resourceUrl == trim($distribution->accessURL)) {
                                    $access_url_match = 'yes';
                                }
                            }
                        }

                        if ('no' == $access_url_match) {
                            $no_match[] = 'http://catalog.data.gov/dataset/'.$ckan_result['name'];
                        }
                    }
                    if (sizeof($no_match) > 1) {
                        $is_geospatial = 'na';
                    }
                    $result_urls_access_url_no_match = join(' | ', $no_match);
                }
            }

            $csv_line = array();
            $csv_line[] = $data->title;
            $csv_line[] = $data->accessURL;

            $id = md5($data->identifier.$data->title);

            $csv_line[] = $json_validation_results[$id]['Valid'] ? 'true' : 'false';

            if (is_array($ers = $json_validation_results[$id]['Errors'])) {
                $csv_line[] = sizeof($ers);
            } else {
                $csv_line[] = 0;
            }

            $csv_line[] = $number_of_matches;
            $csv_line[] = $access_url_match;
            $csv_line[] = $is_geospatial;
            $csv_line[] = $result_urls ?: $result_urls_access_url_no_match;

            fputcsv($fp, $csv_line);
        }
    }

    fclose($fp);
}

/**
 * @param $title
 * @return mixed
 */
function data_gov_json_validator_search_solr($title){
    //search in catalog
    //initialize curl and set base options
    $ch = curl_init(CKAN_URL);
    curl_setopt($ch, CURLOPT_POST, 1);
    curl_setopt($ch, CURLOPT_HEADER, "Content-Type: application/json;charset=utf-8");
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    $solr_request = array(
        'fq'    =>  'title:'.$title,
        'rows'  =>  500,
    );
    $query = json_encode($solr_request);

//    echo $query.'<br />'.PHP_EOL;
//    die($query);

    curl_setopt($ch, CURLOPT_POSTFIELDS, $query);
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 0);
    $curl_output = curl_exec($ch);

    $error = curl_error($ch);
    $result = array( 'header' => '',
        'body' => '',
        'curl_error' => '',
        'http_code' => '',
        'last_url' => '');
    if ( $error != "" ) {
        $result['curl_error'] = $error;
        var_dump($result);
        die();
    }

//    die($curl_output);
    curl_close($ch);
    return $curl_output;
}

function escapeSolrValue($string)
{
    $match = array('\\', '+', '-', '&', '|', '!', '(', ')', '{', '}', '[', ']', '^', '~', '*', '?', ':', '"', ';');
//    $replace = array('\\\\', '\\+', '\\-', '\\&', '\\|', '\\!', '\\(', '\\)', '\\{', '\\}', '\\[', '\\]', '\\^', '\\~', '\\*', '\\?', '\\:', '\\"', '\\;');
    $replace = array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ');
    $string = str_replace($match, $replace, $string);

    return $string;
}